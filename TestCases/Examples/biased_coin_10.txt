//=2*integral  (0.5 ..1) ((1/(1+(1/p-1)^X)*(p^D-(1-p)^D)+(1-p)^D)
B(p,X)=1/(1+(1/p-1)^X)  // prob we selected biased side after X head/tail differences
pW(X,D,p)= (1-p)^D+B(p,X)*(p^D-(1-p)^D)  // prob to win all in D bets after X diff

EVXD(X,D,p,K)= pW(X,D,p)*K^D  // expected value for given X,p,K and assuming D left for betting

EVXp(X,p,K) = sum((d)=>EVXD(X,10-d,p,K)*pX2(X,d,p),X,10)+(1-sum((d)=>pX2(X,d,p),X,10)) // exp value across probable Ds

EVX(X,K)= 2*integral((p)=> EVXp(X,p,K),0.5, 1,100) // exp value across all possible p[0.5,1]

pWA(X,D)= 2*integral((p)=> pW(X,D,p),0.5, 1,10000)




pX(X,N,p)={ // /prob to get X differences H/T for first time after exactly N tosses
  pTot=0;
  pOK=0;
  for(i=0, i<2^N, i=i+1){ // each possible combo of N times H/T
    k=i;
    nB=0; nN=0; pC=1;
    isOK= 1; isX=0;
    for(j=0, j<N, j=j+1){ // check each position of this combo
      if (mod(k,2)==1){
        // biased side
        nB=nB+1;
        pC=pC*p;
      }else{
        // non-biased side
        nN=nN+1;
        pC=pC*(1-p);
      }
      isX=  (abs(nB-nN)==X);
      if ((j<N-1)& isX) isOK=0; // got X before N attempts!
      k= truncate(k/2);
    }
    //if (isOK){pTot=pTot+pC;if (isX) pOK=pOK+pC;}
    pTot=pTot+pC;
    if (isX & isOK) pOK=pOK+pC;
  }
  // final result
  if (pTot==0) return 0;
  return pOK/pTot;
}




X=3; N=4; p=0.9; K=1.367
EVX(X,K)
simEVXp(X,-1,K,10000000)  

EVZ(X,K)= K^(10-X)*pWA(X,10-X)
EVZ(X,K)



//#C#
// probability that biased side has X more than nonbiased side
double pXb(int X, int N, double p, int maxX){
  if ((N<X)|(N<1)) return 0;
  if (N==X) return Math.Pow(p,N);  
  if (N==-X) return Math.Pow(1-p,N);  
  double res = 0;
  if (Math.Abs(X-1)<maxX) res=res+ pXb(X-1,N-1,p, maxX)*p;
  if (Math.Abs(X+1)<maxX) res=res+ pXb(X+1,N-1,p, maxX)*(1-p);  
  return res;
}

// /prob to get X differences H/T for first time after exactly N tosses
double pX2(int X, int N, double p){
    return pXb(X,N,p,X)+pXb(X,N,1-p,X);
}

bool simOnePX2(int X, int N, double p){
    // toss until one side has X more than other
    int nB=0;
    int nN=0;
    int cX=0;
    for(int i=1; i<=N; i++){
        if (Math.Abs(nB-nN)==X) return false;
        if (nm.rnd.NextDouble() <=p) nB++; else nN++;
    }
    return (Math.Abs(nB-nN)==X);
}

double simPX2(int X, int N, double p, int nSim=1000000){
    int nOk=0;
    for(int i=1; i<=nSim; i++)
        if (simOnePX2(X,N,p)) nOk++;
    return nOk/(double)nSim;
}


double simOne(int X, int N, double p, double K){
    // toss until one side has X more than other
    int nB=0;
    int nN=0;
    while (Math.Abs(nB-nN)<X){
        if (nm.rnd.NextDouble() <=p) nB++; else nN++;
    }
    double betP= (nB>=nN)?p:(1-p);
    int D=N-nB-nN;
    if (D<=0) return 1; 
    // now try to win next D, betting on whichever side had more X
    for (int i=1; i<=D; i++)
        if (nm.rnd.NextDouble()> betP) return 0;
    return Math.Pow(K,D);
}

double simEVXp(int X, double p, double K, int nSim=1000000){
    double EV=0;
    bool mixP= (p<0);
    for(int i=1; i<=nSim; i++){
        if (mixP) p=nm.rnd.NextDouble()/2+0.5;
        EV+= simOne(X,10,p,K);
    }
    return EV/nSim;
}

