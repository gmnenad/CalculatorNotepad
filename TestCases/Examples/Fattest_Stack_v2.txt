N=30 // number of boxes

pc(p,k)=1-p^(1/k)  // probability to stop when k boxes remains and to choose that one (! is it dependant on not stopping before ? )
pcn(p,k)= p^sum((i)=>1/i,k+1,N-1) // probability we did NOT select before k = product(1- pc(i)) for i=k+1..N-1
pw(p,k)=(1-p^((N-k)/k))/(N-k) // probability to stop at k and win 
pwk(p,k)= pcn(p,k)*pw(p,k) // probability we select at k-boxes and win (=we did not select before * we choose to select now * we win )
pwin(p)=sum((k)=>pwk(p,k), 0, N-1) // probability we win overall

pwin(0.12) // ??!



csSim(1) // my method, for a=0.950216 , win ~ 52.5%
csSim(2) // Thoks method, for pw=45%  , win ~ 58.9%






//#C#

void prepare(int n, int m){
    N=n;
    M=m;
    A1=(int)(0.950216*M); // a=0.950216 is valid for N==30 ! win~ 52.5%
    pw2=0.45; // pw=45% for N=30 for alg 2 .. estimate ! win~ 58.9% 
}
int N,M;
int A1;
double pw2;
Random rnd=new Random();

// my version, select if X>=A
bool tryOne1(){
    int selected=-1, max=-1;
    for (int i=0; i<N; i++){
        int r= (int)(rnd.NextDouble()*M);
        if ((selected<0)&&(r>=A1)) selected=r;
        if (r>max) max=r;
    }
    return (selected==max); 
}

// Thoks version, select if (X/M)^k >= pw  && X>= current max
bool tryOne2(){
    int selected=-1, max=-1;
    for (int i=0; i<N; i++){
        int X= (int)(rnd.NextDouble()*M);
        if (selected<0){
            int k=N-1-i; // remaining unopened boxes
            if ( (k<=0)||((X>=max)&&(Math.Pow(X/(double)M,k)>=pw2)) ) selected=X;
        }
        if (X>max) max=X;
    }
    return (selected==max); 
}


// try selected algorithm
bool tryAlg(int alg){
    switch(alg){
        case 1: return tryOne1();
        case 2: return tryOne2();
    }
    return false;
}

double csSim(int alg=1, int nSim=1000000, int N=30,int M=1000000){
    prepare(N,M);
    int ok=0;
    for(int i=0; i<nSim; i++)
        if (tryAlg(alg)) ok++;
    return ok/(double)nSim;
}