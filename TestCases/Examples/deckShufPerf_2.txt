map1= vec(26,0,27,1,28,2,29,3,30,4,31,5,32,6,33,7,34,8,35,9,36,10,37,11,38,12,39,13,40,14,41,15,42,16,43,17,44,18,45,19,46,20,47,21,48,22,49,23,50,24,51,25) 
map2= vec(0,26,1,27,2,28,3,29,4,30,5,31,6,32,7,33,8,34,9,35,10,36,11,37,12,38,13,39,14,40,15,41,16,42,17,43,18,44,19,45,20,46,21,47,22,48,23,49,24,50,25,51) 



map181=vec(41,28,38,0,27,22,49,39,16,10,6,1,50,43,35,44,31,4,48,36,19,9,14,18,30,51,34,26,29,46,8,23,13,40,7,17,42,5,25,47,20,3,11,2,12,24,33,37,45,21,15,32)
//v(180180,v(51,28,44,13,16,2,12,21,47,5,36,9,46,14,42,15,3,6,39,37,0,31,8,4,25,10,22,49,18,30,23,32,7,48,43,45,38,50,27,40,41,19,29,20,35,26,1,11,33,24,17,34))
//v(180180,v(8,23,3,42,43,18,7,0,4,49,50,15,25,6,10,16,19,35,30,14,27,46,32,13,33,36,48,40,38,24,31,45,39,41,17,37,28,34,9,22,29,26,51,2,20,5,12,44,47,21,11,1))



// find all groups in map
groups(map0)={
    map=vCopy(map0);
    D=vLen(map);
    nD=D;
    res= vDim(D);
    r=0;
    while (nD>0){
        // find first uncovered
        p0=0; while(map[p0]<0) p0=p0+1;
        // now count and mark all traversed positions
        vg=vDim(D);
        p=p0;
        sz=0;
        do{
            np=map[p];
            map[p]=-1;
            p=np;
            vg[sz]=p;
            sz=sz+1;
        } while(p!=p0);
        // add to results
        res[r]= vec(sz, vTrunc(vg,sz));
        r=r+1;
        nD=nD-sz;
    }
    return vTrunc(res,r);
}


g1=groupsLen(map181)
lcm(g1) // sequence until repeat

// maxSeq(52)=180180,  Landau's function: https://oeis.org/A000793    
maxSeq(10,1000) 
factors(52)
v=vec(26,13,4,4,4,1)
vSum(v)
lcm(v)


v=primesBetween(2,52)
vSum(v)
v2=vFunc((i)=>floor(log(52,i)),v)
vMul(v2)



mxP(n)={
    vp= primesBetween(2,n);
    sm=0;
    k=0;
    while(sm+vp[k]<n) { sm=sm+vp[k]; k=k+1  }
    upr=vFunc((p)=> floor(log(sm,p)), vp[0..k]) ;
    res=vDim(k+1);
    best=1;
    bestVec=0;
    for (ac=counterCreate(upr), counterNotFinished(ac), ac=counterNext(ac)){
        sm=0; prod=1;
        cv= counterValues(ac);
        for(i=0, i<=k, i=i+1) {
            if (cv[i]>0){
                sm=sm+vp[i]^cv[i];
                prod=prod*vp[i]^cv[i];
            }
        }
        if ((sm<=n)&(prod>best)){
            best=prod;
            bestVec=vCopy(cv);
        }
    }
    // form vector
    
    return vec(best, bestVec);
}

m=mxP(52)
lcm(m)



//#C#
// map1, map2:  Qualmans perfect interleave,  1st card become 2nd
int[] makeMap2(int D){
    int[] map=new int[D], deck=new int[D];
    for(int i=0; i<D; i++) deck[i]=i;
    int d2= D/2;
    for(int i=0;  i<d2 ; i++){
        map[2*i]=deck[i];
        map[2*i+1]=deck[i+d2];
    }    
    return map;
}


// find all groups in map, and return their length
List<int> groupsLen(int[] map){
    int D=map.Length, nD=D;
    var res=new List<int>();
    while (nD>0){
        // find first uncovered
        int p0=0; while(map[p0]<0) p0++;
        // now count and mark all traversed positions
        int p=p0;
        int sz=0;
        do{
            int np=map[p];
            map[p]=-1;
            p=np;
            sz++;
        }while(p!=p0);
        // add to results
        res.Add(sz);
        nD-=sz;
    }
    return res;
}

// how many times need to shuffle to return back to original?
int seqMap( int[] map){
    var grp= groupsLen(map);
    return nm.lcm(grp);
}

// randomly find longest sequence for given deck size D . Search up to N times
// result= vec( maxSeqLength, % of trials with that max length )
double[] maxSeq(int D, int n){
    int c=0, cOld=0;
    for(int i=1; i<=n; i++){
        var mp= nm.rndShuffle(D);
        int nc= seqMap(mp);
        if (nc>c){
            c=nc;
            cOld=1;
        }else
            if (nc==c) cOld++;
    }
    return new double[2]{c, 100.0*cOld/(double)n};
}
    



 