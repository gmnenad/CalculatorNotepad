// confidence interval about probability of X, if it happened x out of N times
// returns (avg, moe) wgere MOE= margin of error, so 95% confidence interval is [avg-MOE, avg+MOE]
conf(x,N)={
    p=x/N;
    s=sqrt(p*(1-p)/N);
    return vec(p,1.96*s, 2.58*s);
}

conf(5,100)


// number of tests needed for given MOE ( from confidence interval [avg-MOE, avg+MOE]
minTests(MOE)={
    return 1/MOE^2;
}

minTests(5%)


// guess probability p for binomial distribution if we got x out of N trials ( logical would be p=x/N )
guess(N,x)={
    smP=0;
    smA=0;
    delta=1/1000;
    for(p=0, p<1, p=p+delta){
        d=dist_binomial(N,p); 
        px=pmf(x,d); // probability to get exactly X out of N with this p
        smP= smP+px;
        smA= smA+px*p;
    }
    return smA/smP;
}
// same as above, only possible 'p's are in vector pv
guessV(N,x,pv)={
    smP=0;
    smA=0;
    delta=1/10000;
    for(i=0, i<vLen(pv), i=i+1){
        p=pv[i];
        d=dist_binomial(N,p); 
        px=pmf(x,d); // probability to get exactly X out of N with this p
        smP= smP+px;
        smA= smA+px*p;
    }
    return smA/smP;
}

N=5
x=1
r=guess(N,x)
tst(N,x)
vec( diff(N,x,x/N)[1]:4,diff(N,x,r-0.01)[1]:4,diff(N,x,r)[1]:4,diff(N,x,r+0.01)[1]:4)

//v=vec(1/6,1/5,1/4,1/3,1/2,2/3)
//guessV(N,x,v)
//tstV(N,x,v )



//diff(N,x,r):2

error_margin(95%,2)








//#C#
// until you get 'x' heads randomly select bias 'p' and toss 'N' times
// what is average bias 'p' , given we get x heads out of N trials ?
double tst(int N, int x, int nSim=100000){
    double avgP=0;
    for(int i=0; i<nSim; i++){
        double p;
        int Xk;
        do{
            p= nm.rnd.NextDouble();
            Xk=0;
            for (int k=0; k<N; k++)
                if (nm.rnd.NextDouble()<p) 
                    Xk++;
        }while (Xk!=x);
        avgP+=p;
    }
    return avgP/nSim;
}

// same as above, only possible 'p' biases given in array 'pv'
// return average 'p' and most frequent ( NOT closest) value from array
double[] tstV(int N, int x, double[] pv, int nSim=100000){
    int nv= pv.Length;
    var cntIv=new double[nv];
    double avgP=0;
    for(int i=0; i<nSim; i++){
        double p;
        int Xk,iv;
        do{
            iv= nm.rnd.Next(nv);
            p= pv[iv];
            Xk=0;
            for (int k=0; k<N; k++)
                if (nm.rnd.NextDouble()<p) 
                    Xk++;
        }while (Xk!=x);
        cntIv[iv]++;
        avgP+=p;
    }
    // find most frequent p from pv
    int ib=-1;
    double cb=0;
    for(int i=0; i<nv; i++)
    if (cntIv[i]>cb){
        cb=cntIv[i];
        ib=i;
    }
    return new double[]{avgP/nSim,pv[ib]};
    //return cntIv;
}

// sum of differences between guess and actual probability
// return average probability and average difference
double[] diff(int N, int x, double guess, int nSim=1000000){
    double avgP=0, avgDiff=0;
    for(int i=0; i<nSim; i++){
        double p;
        int Xk;
        do{
            p= nm.rnd.NextDouble();
            Xk=0;
            for (int k=0; k<N; k++)
                if (nm.rnd.NextDouble()<p) 
                    Xk++;
        }while (Xk!=x);
        avgP+=p;
        avgDiff+= Math.Abs(p-guess);
        //avgDiff+= (p-guess)*(p-guess);
    }
    return new double[]{avgP/nSim, avgDiff/nSim};
}
