
//avgRnd()
//simK()



tr(n)={
    res=vDim(32);
    for(i=0, i<n,i=i+1){
        //x=floor(rnd*10);
        x=floor(((4*rnd)^2+(4*rnd)^2));
        //x=floor(20*(rnd*rnd));
        res[x]=res[x]+1;
    }
    for(i=0, i<20,i=i+1) res[i]=round(res[i]/n*100,2); // as %
    return res;
}


//v=tr(1000000)  
//vSum(v)


sim(pi/4)  // pi/4

pi/3/sqrt(3)
pi/4

//#C#
int doOneCircle(double R){ // original R=pi/4
    int score=0;
    // ratio R= ininital area / total area 
    // R2= total area / pi , and initial area=1*pi, so R2=1/R
    // M= max radius of total area
    double r2=1; // r2=R means initial circle is smaller
    double h2=0, R2= r2/R, M= Math.Sqrt(R2); 
    do{
        score++;
        r2=r2-h2;
        double x,y;
        do{ // find random point within circle with R2
            x=2*M*nm.rnd.NextDouble()-M; // -M..+M
            y=2*M*nm.rnd.NextDouble()-M;
            h2=x*x+y*y;
        }while(h2>R2);
    }while(h2<r2);
    return score;
}

int doOneSquare(double R){ 
    int score=0;
    // ratio R= ininital target area / total area 
    // T = target circle area T divided by PI 
    // H = hit area / pi , circle between dart and center
    double T=4*R/Math.PI, H;
    bool hit;
    do{
        score++;
        // find random point within square with -1..+1
        double x,y;
        x=2*nm.rnd.NextDouble()-1; 
        y=2*nm.rnd.NextDouble()-1;
        H=x*x+y*y;
        hit= H < T;
        //T= T-H; // Chord as new target radius 
        T= H; // Dart-to-center as new target radius
        //T= T+H-2*Math.Sqrt(T*H); // ! Dart-to-edge as new target radius !
    }while( hit );
    return score;
}



int doOneRectangle(double R){ 
    int score=0;
    // ratio R= ininital area / total area 
    // R2= total area = fixed 4 here
    // M= HALF the size of square with total area R2 = 1 here
    double xT=Math.Sqrt(R/4), yT=xT;
    bool hit;
    do{
        score++;
        double x,y;
        // find random point within square with R2
        x=2*nm.rnd.NextDouble()-1; // -1..+1
        y=2*nm.rnd.NextDouble()-1;
        hit=(Math.Abs(x)<=Math.Abs(xT))&&(Math.Abs(y)<=Math.Abs(yT));
        xT=x; yT=y;
    }while(hit);
    return score;
}

// R=fraction (<=1) of initial target area (1*pi) to total area
double[] sim(double R, int nSim=1){
    nSim*=10000000;
    double scoreCircle=0, scoreSquare=0, scoreRectangle=0;
    for(int i=0; i<nSim; i++){
        scoreSquare+= doOneSquare(R);
        //scoreCircle+= doOneCircle(R);
        scoreRectangle+= doOneRectangle(R);
    }
    double eS= Math.Pow(Math.E, R);
    return new double[]{scoreRectangle/nSim, scoreSquare/nSim, eS};
}


double avgRnd(int nSim=1){
    nSim*=100000000;
    double res=0;
    for(int i=nSim; i>0; i--){
        double x= nm.rnd.NextDouble();
        double y= Math.Sqrt(1-x*x);
        res+=y;
    }
    return res/nSim;
}