R=1
V=2
F=1/(1+pi)

difft(p)={
    d= R*F+R*(1-F)*p;   //princess distance from center 
    x= R*(1-F)*(1-p);   // remaining princess distance to shore 
    a= p*pi;            //  angle between new point opposite orc and north
    c= sqrt(d^2+R^2-2*d*R*cos(a));  // distance of boat to new point 
    tp= (c-x)/(F*V);                // increased time for princess
    to= a*R/V;                      // increased time for orc 
    return to-tp;
}

tfr(dt)={
    a=dt*V/R;
    Vb=V*F;
    d=dt*Vb;
    x=Vb*dt;
    t=0;
    do{
        c=2*x*sin(a/2);
        xb=2*c*cos(a/2);
        xc=c^2-d^2;
        dx=(-xb+sqrt(xb^2-4*xc))/2;
        x=x+dx;
        t=t+dt;
    }while(x<F*R);
    return vec(t,x/F*R-1);
}

t2(p)= R/V*ln(p)
tfd(D)= R/V*ln(10)*D

digits=15

tfd(digits)
r=tfc(digits)







//#C#
double[] tfc(int digits, double dt=1e-5){
    const double V=2;
    const double R=1;
    const double F=1/(1+Math.PI);
    const double FR= F*R;
    double p=Math.Pow(10,-digits);
    var end= FR*(1-p);
    var Vb=V*F;
    //double dt= FR*p/Vb/10;
    var a=dt*V/R;
    var d=dt*Vb;
    var x=Vb*dt;
    var w1=-Math.Sin(a);
    var w2=Math.Pow(Math.Sin(a),2)-4*Math.Pow(Math.Sin(a/2),2);
    var w3=d*d;
    double t=0, x0;
    int cntZeros=0;
    do{
        x0=x;
        var dx= w1*x+Math.Sqrt(w2*x*x+w3);
        x+= dx;
        if (x==x0) cntZeros++;
        t+= dt;
    }while((x<end)&&(cntZeros<10));
    double precision= Math.Round(-Math.Log10(Math.Abs(x/FR-1)));
    return new double[]{t, precision };    
}