// N= number of boxes, k=skip first k, S=selest Sth larger box after k -> pw= prob to select largest
pw(N,k,S)=if(k>0, k/N*sum((x)=> product((i)=> 1-(k-1)/(N-i),1,x) /x , S, N-k) , 1/N)

// find best k, for max probability of win
pm(N)={
    S=1;
    bestP=1/N;
    bestK=0;
    for(k=1, k<N, k=k+1){
        p1=pw(N,k,S);
        if (p1>=bestP){
            bestP=p1;
            bestK=k;
        }
    }
    return vec(bestK, bestP, pw(N,bestK,2));
}

pm(100)
pm(37)


pr(100)
pwk(37,vec(100))
pwk(19,vec(37,100))
pwk(20,vec(37,100))
pwk(22,vec(37,100))
pxb(vec(37,100)) // find best K for given range
sim(22,vec(37,100),100000)      // X=22: 22.46% total, 35.63% self
simX(vec(37,22),1,100000) 


//v=simAll(vec(37,100),10000000) // 22 , but 21&23 within 0.2%
//v=simAll(vec(22,37,100),10000000) // 14, but 13-15 within 0.5%
//v=simAll(vec(14,22,37,100),10000000) // 9, but 8 within 0.2%
//v=simAll(vec(9,14,22,37,100),10000000) // 5, but 6 within 0.2%
//v=simAll(vec(5,9,14,22,37,100),10000000) // 3, but 4 within 0.2%
//v=simAll(vec(3,5,9,14,22,37,100),10000000) // 2, but 3-4 within 7%
//v=simAll(vec(2,3,5,9,14,22,37,100),10000000) // 1, but 2-4 within 14%
//v=simAll(vec(1,2,3,5,9,14,22,37,100),10000000) // 1, but 2-4 within 0% !!
//v=simAll(vec(1,1,2,3,5,9,14,22,37,100),10000000) // 0, no nearby result
//v=simAll(vec(0,1,1,2,3,5,9,14,22,37,100),10000000) // 0, but 0-6 all same result within 0% 
//v=simAll(vec(0,0,1,1,2,3,5,9,14,22,37,100),10000000) // 0, but 0-8 all same result within 0% 
//v=simAll(vec(0,0,0,1,1,2,3,5,9,14,22,37,100),10000000) // 0, but 0-8 all same result within 0% 

//v=simAll(vec(37,100),10000000) // 22 in 18sec, but 21 within 0.1%
//v=simAll(vec(22,37,100),10000000) // 14 in 28sec, but 13 within 0.1%
//v=simAll(vec(14,22,37,100),10000000) // 9 in 47sec, but 8 within 0.3%
//v=simAll(vec(9,14,22,37,100),10000000) // 5 in 74sec, but 6 within 0.1%
//v=simAll(vec(5,9,14,22,37,100),10000000) // 3 in 114sec, but 4 within 0.5%
//v=simAll(vec(3,5,9,14,22,37,100),10000000) // 2 in 179sec, and 3-4 within 7%
//v=simAll(vec(2,3,5,9,14,22,37,100),10000000) // 1 in 284sec, and 2-4 within 13%
//v=simAll(vec(1,2,3,5,9,14,22,37,100),10000000) // 1 in 480sec, and 1-4 within 0% !!!
//v=simAll(vec(1,1,2,3,5,9,14,22,37,100),10000000) // 0 in 809sec, no other result within 60%
//v=simAll(vec(0,1,1,2,3,5,9,14,22,37,100),1000000) // 0 in 809sec, no other result within 60%
findBest(v,60%)

//v=vec(86,0,31,1,56,2,4,68,7,11,19,37,100) // old order, with bug
//v=vec(0,0,0,1,1,2,3,5,9,14,22,37,100) // new order, with fixed total nsim
//r=winStats(v,100000) 
//r[0]
//37(37%), 19(32%), 11(27%), 7(23%), 68(23%), 4(23%), 2(20%), 56(20%), 1(19%), 31(18%), 0(16%), 86(16%)
// total chance to find after 12 suitors: 96%

// standard deviation of simulations
simDev(X,n)={
   res=vDim(n);
   for(i=0, i<n, i=i+1)
     res[i]= sim(X,vec(37,100),630000)[1];
   return vStdDev(res);
}

//simDev(22,10)*100
choose(5,2)
80*79-20*19
2*20*60+60*59

80*79-20*19
2*20*60+60*59







//#C#
// prob that X larger values are in specific rightside subgroup G
//  - G: size of subgroup, N=( ..Left..|..G..|..right rest.. )
//  - N: total number of elements/boxes/persons
double pg(int X, int G, int K, int N){
    if (X>G) return 0;
    //if (nmCache.Try("pg",X,G,K,N)) return nmCache.Result;
    double res=1;
    if (X>0){
        for (int i=0; i<X; i++)
            res *= (G-i)/(double)(N-1-i);
    }
    res*=K/(double)N;
    //nmCache.Add("pg",X,G,K,N,  res);
    return res;
}
 
// prob to select next largest among X
//  - K: number to skip in first range R[0]
//  - Ranges: last element in each range
//            for first Player(R[0]=100), for 2nd(R[0]=37, R[1]=100) ...
//  assuming (X+1)th largest is on left side 
double pwx(int X, int K, int N, int[] Ranges){
    if (X==0) return K/(double)N;
    int P= Ranges.Length; // assume ranges values are same for previous players ( R[2+...]
    // pr[P]= chance we do NOT have X on right
    // pr[0] = all X in range K..R[0], pr[1]= all X in range K..R1 but not in pr[0]...
    var pr= new double[P+1]; 
    int range=0;
    int lastRange=K;
    double lastPrn=0;
    // for other ranges reduced probability since previous players already tried
    // pr[i]= probability to have i filled ranges , i=0..suitor-1 = [0..P>
    for (int i=0; i<P; i++){
        range+= Ranges[i]-lastRange; // expand range
        lastRange=Ranges[i];
        var prn=pg(X, range, K,N); // all X in subgroups 0..i 
        double pfa= prn - lastPrn; // at least one in subgroup i
        pr[i]=pfa;
        lastPrn=prn;
    }
    pr[P]=1-lastPrn; // chance we do not have exactly X larger on right of K
    double res=0;
    // optional Bayesian renormalization of E probabilities
    if (false){
        //pr[i]= i<X? pfa*(X-i)/X:0; // prob without failed cases from prev ppl
        // Bayesian renormalization of pr
        double pSum= pr.Sum();
        if (pSum>0){
            for (int i=0; i<=P; i++) pr[i]/=pSum;
            // probability that largest one is first among those X
            for (int i=0; i<P; i++)
                if (i<X)
                    res+= pr[i]/(X-i); 
            return res;
        }
    }
    // for each E, calculate probability to win
    for (int i=0; i<P; i++){
        double pW=X>i? 1/(double)X:0;
        res+= pr[i]*pW;
    }
    return res;
}

// probability to win for Ranges based on specific K=Ranges[0]
//  - K: number of elements to skip in first range
//  - Ranges.Length = P = which player/suitor is now trying
//  - N : total number of elements/boxes/people = Ranges.Sum()
double pwk(int K, int[] Ranges, int N=-1){
    if (N<0) N=Ranges[Ranges.Length-1];
    double res=0;
    for (int X=1; X<=N-K; X++)
        res+= pwx(X,K,N, Ranges);
    return res;
}

// find best K for given ranges
double[] pxb(int[] Ranges, int N=-1){
    if (N<0) N=Ranges[Ranges.Length-1];
    int bestK=0;
    double bestP=0;
    for (int K=0; K<Ranges[0]; K++){
        double p=pwk(K, Ranges, N);
        if (p>=bestP){
            bestP=p;
            bestK=K;
        }
    }
    return new double[]{bestK, bestP};
}

// find skip points for each player 
int[] pr(int N){
    var Ranges= new int[1]{N};
    while(Ranges[0]>0){
        var b= pxb(Ranges,N);
        var oldR= Ranges;
        Ranges= new int[Ranges.Length+1];
        Ranges[0]=(int)b[0];
        for(int i=0; i<oldR.Length; i++)
            Ranges[i+1]=oldR[i];
    }
    var res= new int[Ranges.Length];
    for (int i=0; i<Ranges.Length; i++) res[i]=Ranges[Ranges.Length-1-i];
    return res;
}

// ***********************************************
// SIMULATION PART

int N;
double targetBest;
double[] deck;
bool[] selDeck;

void makeDeck(int alg=2){
    switch(alg){
      case 1:
        var iDeck=nm.rndShuffle(N); 
        targetBest= N-1;
        for (int i=0; i<N; i++)
            deck[i]=iDeck[i];
        break;
      case 2:
        targetBest= -1;
        for (int i=0; i<N; i++){
            var d= nm.rnd.NextDouble();
            if (d>targetBest) targetBest=d;
            deck[i]=d;
        }
        break;
      case 3:
        targetBest= -1;
        for (int i=0; i<N; i++){
            var d= nm.rnd.Next(N);
            if (d>targetBest) targetBest=d;
            deck[i]=d;
        }
        break;
    }  
    // clear already selected marks
    for(int i=0; i<N; i++) selDeck[i]=false;
}

// try previous players and mark deck
bool tryP(int X){
    // skip first K and remember HighestSoFar
    double HSF=-1;
    for (int i=0; i<X; i++) 
        if (deck[i]>HSF) HSF=deck[i];
    // now select first higher than that
    for (int p=X; p<N; p++){
        double v=deck[p];
        if (v>HSF){ // if this is new HSF
            HSF=v;
            if(!selDeck[p]){ // if it was not selected by previous suitors
                selDeck[p]=true;
                return ( v==targetBest); // we win if this selection is largest possible value, or N-1
            }
        }
    }
    return false;
}

// simulate arrangements where all previous in ranges failed, and last suitor is trying at K
// previous{37,100} means N=100, 1st suitor skipped 37 and failed
double[] sim(int K, int[] previous, int nSim=1000){
    int nOK=0, nTest=0, nTry=0;
    int P=previous.Length;
    N=previous[P-1];
    deck= new double[N];
    selDeck= new bool[N];
    while (nTest<nSim){
        nTry++;
        makeDeck(); // create random arrangement
        bool ok=true; // check if all previous players failed
        for (int p=P-2; (p>=0)&&ok; p--)
            if (tryP(previous[p])) ok=false;
        if (ok){
            nTest++;
            if (tryP(K)) nOK++; // if last player find, record it
        }
    }
    return new double[]{nOK/(double)nTest, nOK/(double)nTry, (nTry-nTest)/(double)nTry, nTry};
}



// simulate arrangements where i-th suitor skipped skips[i]. skips[]={37,22,...}
// return probability of each suitor to win ( clean if tRes=1, solo if tRes=2)
double[] simX(int[] skips, int tRes=1, int nSim=10000000,  int N=100){
    var S= skips.Length;        // number of suitors [0..S-1]
    var tries= new int[S];      // count how many times each suitor tried
    var wins=  new int[S];      // count how many times each suitor wins
    var dowries= new double[N]; // random values of dowries [0..N-1]
    // repeat all trials
    for (int trial=0; trial<nSim; trial++){
        // create random arrangement of N dowries and remember best one
        double targetBest= -1;
        for (int i=0; i<N; i++){
            var d= nm.rnd.NextDouble()+1;
            if (d>targetBest) targetBest=d;
            dowries[i]=d;        
        }
        // each suitor try until found or all tried
        bool found=false; 
        for( int s=0; (s<S)&& !found; s++ ){
            tries[s]++; // mark that s-th suitor tried
            int X=skips[s]; 
            // skip first X and remember HighestSoFar
            double HSF=-1;
            for (int i=0; i<X; i++) if (Math.Abs(dowries[i])>HSF) HSF=Math.Abs(dowries[i]);
            // now select first higher than that
            bool selected=false;
            for (int i=X; (i<N)&&!selected; i++){
                var v= Math.Abs(dowries[i]);
                if (v>HSF){ // if this is new HSF
                    HSF= v;
                    if (dowries[i]>0){ // if not previously selected by other suitors
                        selected=true;
                        if (v==targetBest){ // check if he found best
                            found=true;  // mark found, so next suitor does not get to try
                            wins[s]++;   // increment win count
                        }
                        // mark this dowry as previously selected
                        dowries[i]=-v;
                    }
                }
            }
        }
    }
    // result probabilities. 'clean' are wins/nSim, 'solo' are wins/tries
    var res= new double[S];
    for (int s=0; s<S; s++) res[s]=(double)wins[s]/(tRes==1?nSim:tries[s]); 
    return res;
}


// searching ALL K 
double[] kok;

// try last player for ALL K, and mark K array. Assume largest not found yet
void tryLast(){
    // find place of largest, and HSF before largest
    int p=0,pHsf=-1;
    double HSF=-1;
    while(deck[p]<targetBest){
        if (deck[p]>HSF){
            HSF=deck[p];
            if (!selDeck[p]) pHsf=p; // only remember last one he would choose
        }
        p++;
    }
    // only those K at or after last pHsf, and before p_largest, would find largest
    // +1 since p/pHsf are zero-based
    for(int i=pHsf+1; i<=p; i++)
        kok[i]++;
}

// try all K for last suitor, return probabilities for every K
double[] simAll(int[] previous, int nSim=10000000){
    int nTest=0, nTries=0;;
    int P=previous.Length;
    N=previous[P-1];
    kok= new double[N];
    deck= new double[N];
    selDeck= new bool[N];
    //for (int trial=0; trial<nSim; trial++){
    while(nTest<nSim){
        nTries++;
        makeDeck(); // create random arrangement
        bool ok=true; // check if all previous players failed
        for (int p=P-2; (p>=0)&&ok; p--)
            if (tryP(previous[p])) ok=false;
        if (ok){
            nTest++;
            tryLast(); // increase kok for Ks that would have found best
        }
    }
    // return probabilities for each K in vector
    for (int i=0; i<N; i++) kok[i]/=nTries;
    return kok;
}

// find best K from 'simAll' results, and those within X%
mcValue findBest(double[] kok, double withinP=0.1){
    // find best value and K
    double bV=-1;
    int bP=-1;
    for(int i=0; i<kok.Length; i++)
    if (kok[i]>bV){
        bV=kok[i];
        bP=i;
    }
    // find all within 10%
    var L=new List<int>();
    for(int i=0; i<kok.Length; i++)
        if (kok[i]/bV>1-withinP)
            L.Add(i);
    // make result
    var vL= new List<mcValue>();
    vL.Add( new mcValue(bP));
    vL.Add( new mcValue(L));
    var res= new mcValue(vL);
    return res;
}


// statistics for win chances of each suitor. 
// returns { {pWin, pWinAfter, ntests, pWinTot, K, #suitor},...}
mcValue winStats(int[] ranges, int nSim=1000000){
    int P=ranges.Length-1;
    N=ranges[P];
    deck= new double[N];
    selDeck= new bool[N];
    var wins= new double[P];
    var tests= new int[P];
    for(int i=0; i<nSim; i++){
        makeDeck();
        bool found=false;
        for (int p=P-1; (p>=0)&& !found; p--){
            tests[p]++;
            if (tryP(ranges[p])){
                wins[p]++;
                found=true;
            }
        }
    }
    // make result
    var vRes= new List<mcValue>();
    double sumWins=0;
    for (int i=P-1; i>=0; i--) {
        sumWins+=wins[i];
        double pWin= tests[i]>0? wins[i]/tests[i]:0;
        double pWinAfter= wins[i]/nSim;
        double pWinTot= sumWins/nSim;
        var vOne = new List<mcValue>();
        vOne.Add( new mcValue(pWin));
        vOne.Add( new mcValue(pWinAfter));
        vOne.Add( new mcValue(tests[i]));
        vOne.Add( new mcValue(pWinTot));
        vOne.Add( new mcValue(ranges[i]));
        vOne.Add( new mcValue(P-i));
        vRes.Add( new mcValue(vOne));
    }
    var res= new mcValue(vRes);
    return res;
}