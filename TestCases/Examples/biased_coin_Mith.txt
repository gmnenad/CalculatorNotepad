// probability to win next 'b' bets if out of previous N bets we had M misses (confirmed with sim)
p(N,M,b)= (N-M+b)!/(N-M)!*(N+1)!/(N+1+b)!
p1(N,M)= (N-M+1)/(N+2)  // probability to win next 1 bet
p10(N,M)= (10-M)!/11!*(N+1)!/(N-M)! // probability to win next up to 10 bets ( so 10-N bets )
ex10(N,M,K)= p10(N,M)*K^(10-N) // expected value multiplier if we bet all up to 10 after initial N tosses

// deep ex = consider not betting on next, check if it yield better expectations
// return vec(ex, avgN, skipThis): ex=expected value, avgN= average bets to skip, skip
dex10(N,M,K) ={
    if (N>=10) return vec(1,N,1); // if we already bet 10 times, we can not bet anymore
    ex= ex10(N,M,K); // ex if we start now to bet on all next up to 10
    pw1=p1(N,M); // chance that next will be same as majority in previous N
    dx1M0=dex10(N+1,M,K); // if win next, M remains same
    dx1M1=dex10(N+1, min(M+1,N-M), K); // otherwise M++ unless it pass half (then N-M )
    ex1= pw1*dx1M0[0] + (1-pw1)*dx1M1[0]; // average ex if we wait 
    wn1= pw1*dx1M0[1] + (1-pw1)*dx1M1[1]; // average wait N++
    // see if better to wait or not
    res=vec(ex,N,0);
    if (ex1>ex) res=vec(ex1,wn1,1);
    if (res[0]<1) res=vec(1,N,1); // if it is better to skipp all next bets, do it
    return res;
}


N=1
M=0
K=1.27
p10(N,M)
ex10(N,M,K)
ex10(N+1,M,K)
dex10(N,M,K)


simEx(1,K,100000)
simEx(2,K,100000)



//simDEX(1.26 ) 
mat1(1,1.2713167)





//#C#
// simulate skipping X, then bet all on rest 10 only if all X are same, otherwise do not bet at all
double simEx(int N, double K, int nSim){
    double res=0;
    for(int s=0; s<nSim; s++){
        double p= nm.rnd.NextDouble();
        int H=0, T=0;
        for(int i=0; i<N; i++)
            if (nm.rnd.NextDouble()<p) H++; else T++;
        double ex=1;
        // if not all same, do not bet at all
        if ((H==N)||(T==N)){  
            bool betOnH= (H>=T);
            // bet to all 10
            for(int b=N+1; (b<=10)&&(ex!=0); b++)
                if ( betOnH == (nm.rnd.NextDouble()<p)) 
                    ex*=K;
                else
                    ex=0;
        }
        // update expected
        res+=ex;
    }
    return res/(double)nSim;
}

// expected value multiplier if we bet all up to 10 after initial N tosses
double exAll(int N,int M, double K){ 
    // p10(N,M)=(10-M)!/11!*(N+1)!/(N-M)!
    double p= nm.Factorial(10-M)/nm.Factorial(11)*nm.Factorial(N+1)/nm.Factorial(N-M);
    return p*Math.Pow(K,10-N);  // p10(N,M)*K^(10-N) 
}

// create bet matrix[N,M]: 
//  +positive= bet all from now, value=expected
//  -negative= skip this bet, value=-expected
double[,] genMat(double K){
    var res=new double[11, 6];
    // create for N=10 : always skip, expect=1
    for(int m=0; m<=5; m++) res[10,m]=-1;
    // create for all other Ns, rolled out recursion
    for(int N=9; N>=0; N--){
        // for each possible M given this N
        for(int M=0; M<N/2+1; M++){
            double ex= exAll(N,M,K); // ex if we start now to bet on all next up to 10
            double pw1= (N-M+1)/(double)(N+2); // chance that next will be same as majority in previous N
            double dx1M0= Math.Abs(res[N+1,M]); // if win next, M remains same
            double dx1M1= Math.Abs(res[N+1, Math.Min(M+1,N-M)]); // otherwise M++ unless it pass half (then N-M )
            double ex1= pw1*dx1M0 + (1-pw1)*dx1M1; // average ex if we wait 
            // see if better to wait or not
            if (ex1>ex) ex=-ex1; // negative indicate we should wait
            if (Math.Abs(ex)<1) ex=-1; // if bet is not good, do not bet at all
            // store res in matrix
            res[N,M]=ex;
        }
    }
    return res;
}

// return one strip from mat: all Ms for given N
double[] mat1(int N, double K){
    var mat= genMat(K);
    int szM=N/2+1;
    var res= new double[szM];
    for(int m=0; m<szM; m++) res[m]=mat[N,m];
    return res;
}

// simulate for given K
double simDEX(double K, int nSim=20000000  ){
    var mat= genMat(K);
    double res= 0;
    for (int s=0; s<nSim; s++){
        double p= nm.rnd.NextDouble();
        // skip until appropriate
        int H=0, T=0 ;
        bool skip=true;
        do{
            int M= Math.Min(H,T); // M= number of 'misses' = 0 when all same side
            if (mat[H+T,M]>0) // we need to skip if precomputed matrix says so (negative ex)
               skip=false;
            else
               if (nm.rnd.NextDouble()<p) H++; else T++; 
        }while( skip &&(H+T<=10));
        // now bet all remaining on whichever side dropped most
        bool betOnHeads= (H>=T);
        double ex=1;
        for(int b=H+T+1; (b<=10)&&(ex!=0); b++) 
            if ((nm.rnd.NextDouble()<p) == betOnHeads) ex*=K; else ex=0;
        // update stats
        res+=ex;
    }
    return res/(double)nSim;
}