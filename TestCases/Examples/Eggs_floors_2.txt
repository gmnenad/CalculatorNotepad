// max number of floors that can be measured with given number of eggs and measurement tries
mr(eggs, tries)={
    r=0;
    if (eggs>0) for(t=1, t<=tries, t=t+1) r=r+1+mr(eggs-1, t-1);
    return r;
}
// binomial coefficient alternative, faster than above recursive
// http://www.cs.umd.edu/~gasarch/BLOGPAPERS/eggold.pdf
mrb(eggs, tries)={
    r=0;
    for(i=1,(i<=eggs)&(i<=tries), i=i+1) r=r+ choose(tries,i);
    return r;
}


// min tries needed to test number of floors with given number of eggs in worst case
mt(floors, eggs)={
    if (floors==1) return floors;
    for(t=1,1,t=t+1) if (mrb(eggs,t)>=floors) return t;
}
// binary search optimized alternative to 'mt' :  mt(1e40,10)=3112ms,  mtb(1e40,10)=1ms ( both use mrb)
mtb(floors, eggs)={
    if ((eggs==1)|(floors==1)) return floors;
    twoEggSolution= ceiling((sqrt(8*floors+1)-1)/2);
    if (eggs==2) return twoEggSolution;
    startSearch= log(floors,2); // best case (smallest possible number of trials) with binary search
    endSearch= twoEggSolution; // worst case (most needed trials) is two eggs solution
    approx= (eggs!*floors)^(1/eggs); // optional further reduction of search ramge with approx result +- err
    if ( not isInfinity(approx)){
        err= eggs/2+2; // maximal approximation error (+2 just in case)
        startSearch= max(startSearch, approx-err);
        endSearch= min(endSearch, approx+err);
    }
    return binarySearch((t)=> mrb(eggs,t)>=floors ,  ceiling(startSearch), ceiling(endSearch));
}


// mtb(600,3) // 5704ms
// mt(600,3) // 1ms  with choose and recursive
//mt(10000000000,12) // 4913 for mr, 23ms for mrb


// at what floors to test with first egg, given total eggs and floors above/below test range
ft(aboveFloor, belowFloor, eggs)={
    floors= belowFloor-aboveFloor-1;
    t=mt(floors,eggs);
    f=0;
    r=vDim(t);
    for(i=0, f<floors, ){
        f=f+mr(eggs-1,t-i-1)+1;
        if (f<=floors){
            r[i]=f+aboveFloor;
            i=i+1;
        }
    }
    res=vDim(i,(k)=>r[k]);
    return res;
}


// math formula for covered floors with N max trials, given fixed number of eggs
//      f1(N)= N                                        ; with 1 egg
//      f2(N)= sum(t=1..N) (1+f1(t-1)) = N*(N+1)/2       ; with 2 eggs
//      f3(N)= sum(t=1..N) (1+f2(t-1)) = N*(N^2+5)/6     ; with 3 eggs
//      f4(N)= sum(t=1..N) (1+f3(t-1)) = N*(N+1)*(N^2-3*N+14)/24     ; with 4 eggs
//      f5(N)= N*(N^4-5*N^3+25*N^2+5*N+94)
// or if f(N,E) is covered floors with N max trials and E eggs, then:
//      f(N,1)=N
//      f(N,E)= sum(t=1..N) (1+f(t-1,E-1))
// so mt(1000,3) can be solved by f3(N)>=1000 or N(N^2+5)/6>=1000 or N>=18.079 so N==19 
// wolfram can solve for N eggs:  
//      2 eggs(n=44.22): sum(a=0..n-1)(1+a)=1000
//      3 eggs(n=18.08): sum(b=0..n-1)(1+ sum(a=0..b-1)(1+a))=1000
//      4 eggs(n=12.72): sum(c=0..n-1)(1+ (sum(b=0..c-1)(1+ sum(a=0..b-1)(1+a))))=1000
//      5!eggs(n=10.95): sum(d=0..n-1)(1+(sum(c=0..d-1)(1+ (sum(b=0..c-1)(1+ sum(a=0..b-1)(1+a))))))=1000
// root solutions for different number of eggs, given F floors:
//      1: N=F
//      2: N=(sqrt(8*F+1)-1)/2
//      3: N~ (6*F)^(1/3) ≈ 0.48075*(1.73205*sqrt(243*F^2+125)+27*F)^(1/3)-3.46681/(1.73205*sqrt(243*F^2+125)+27*F)^(1/3) 
//      4:?N≈0.5*sqrt((0.333333*(205-288*F))/(18*sqrt(73728*F^3+50496*F^2+383792*F+62181)+8208*F+5363)^(1/3)+0.333333*(18*sqrt(73728*F^3+50496*F^2+383792*F+62181)+8208*F+5363)^(1/3)-6.33333)-0.5*sqrt(-(0.333333*(205-288*F))/(18*sqrt(73728*F^3+50496*F^2+383792*F+62181)+8208*F+5363)^(1/3)-0.333333*(18*sqrt(73728*F^3+50496*F^2+383792*F+62181)+8208*F+5363)^(1/3)-48/sqrt((0.333333*(205-288*F))/(18*sqrt(73728*F^3+50496*F^2+383792*F+62181)+8208*F+5363)^(1/3)+0.333333*(18*sqrt(73728*F^3+50496*F^2+383792*F+62181)+8208*F+5363)^(1/3)-6.33333)-12.6667)+0.5

approx(floors,eggs)={
    return ceiling((eggs!*floors)^(1/eggs));
}

approx2(floors,eggs)={
    H=floor(eggs/2)-1;
    L=-floor((eggs+1)*0.4);
    x0=2^floor((eggs+3)/2);
    k=1/(H/L-1)/(1-1/x0);
    corr=k*(H-L)*(1-1/floors)+L;
    return ceiling((eggs!*floors)^(1/eggs)+corr);
}

approx3(floors,eggs)={
    return ceiling((eggs!*floors)^(1/eggs)-(eggs+1)*0.4+log(floors/2,4));
}


approx(10,6)
approx3(10,6)
mt(10,6)


diff(eggs)={
    md=6;
    res=vDim(md);
    d=0; t=1; oldT=1;
    // find highest starting with difference ( so all before also have difference)
    while (mt(t,eggs)!=approx2(t,eggs)){
        oldT=t;
        t=ceiling(t+t/10+1);
    }
    if (t>1){
        res[d]=vec(oldT,mt(oldT,eggs),approx2(oldT,eggs));
        d=d+1;
    }
    t= ceiling(log(t));
    while((d<md)&(t<10)){
        trials=10^t;
        amt=approx2(trials,eggs);
        rmt=mt(trials,eggs);
        if (amt!=rmt){
            res[d]=vec(-t,rmt,amt);
            d=d+1;
        }
        t=t+1;
    }
    return vDim(d,(i)=>res[i]);
}
diff(4)

// trials at which difference change first time, and how many oscilations for previous
difL(eggs)={
    md=30;
    res=vDim(md);
    lastDiff= approx(1,eggs) - mt(1,eggs);
    lastT=1;
    lastVal=lastDiff;
    d=0; t=1; osc=0;
    // one by one
    while((d<md)&(t<=2^30)){
    if (t<1024) t=t+1; else t=t*2;
        newDiff= approx(t,eggs) - mt(t,eggs);
        if (newDiff!=lastVal){
            osc=osc+1;
            lastVal=newDiff;
        }
        if (newDiff < lastDiff){ // != for all oscillations, < for just next
        res[d]=vec(lastT,lastDiff);//,osc);
            lastDiff=newDiff;
            lastT=t;
            osc=0;
            d=d+1;
        }
    }
    res[d]=vec(lastT,lastDiff);
    return vDim(d+1,(i)=>res[i]);
}
difL(5)

// first trial where approx is lower than actual,  diff at large trials, diff at 1, diff at 10
difM(eggs)={
    t=1;
    while((t<64)&(approx(t,eggs) - mt(t,eggs)>0)) t=t+1;
    while(approx(t,eggs) - mt(t,eggs)>0) t=t*2;
    return vec(log(t,2) );
}
difM(7)

eg=10; t2=1000



approx(t2,eg) - mt(t2,eg)





// optimal trials for different number of eggs, given fixed steps/floor count
// return vec( trials for 1 egg, trials for 2 eggs, ...) , stops at min possible value
// it has lower bound - when 'opt trials' <= 'number of eggs', opt trials can not go lower
// and that lower 'opt trial' bound can be reached much sooner than at same number of eggs
opT(floors)={
    res=vDim(1000);
    ot=1000;
    for(i=1, i<=ot+1, i=i+1){
        ot= mt(floors,i);
        res[i-1]= ot;
    }
    while((ot>1)&(res[ot-1]==res[ot])) ot=ot-1;
    return vDim(ot+1, (k)=>res[k]);
}

// costs with different number of eggs and their optimal trials 
cosT(floors, costEgg, costTrial)={
    o= opT(floors);
    return vDim( vLen(o), (i)=> (i+1)*costEgg+o[i]*costTrial);
}

// cheapest approach to measure floors, given costs of single measurement and egg
// return vec ( max cost, number of needed eggs, max tries)
bestC(floors, costEgg, costTry)={
    ctv= cosT(floors, costEgg, costTry);
    eggs=0;
    for (i=1, i<vLen(ctv), i=i+1)
        if (ctv[i]<ctv[eggs])
            eggs=i;
    return vec(ctv[eggs], eggs+1, mt(floors,eggs+1));
}


cE=1; cT=1 ; nFloors=4
opT(nFloors)                // optimal trials for different number of eggs ( given fixed floors)
cosT(nFloors,cE,cT)         // costs if different number of eggs is used
br=bestC(nFloors,cE,cT)     // lowest cost:  vec( maxCost, nDevices-eggs, maxTries) 

ft(0,nFloors+1,br[1],0)     // steps at which to test with first device (drop first egg)


// floors where price increase (max N), for fixed cost egg/trial
floorJumpsC(costEgg, costTrial, N)={
    res=vDim(N);
    F=1;
    nr=0;
    while(nr<N){
        cst=bestC(F,costEgg, costTrial)[0];
        res[nr]= F;
        nr=nr+1;
        while ( bestC(F,costEgg, costTrial)[0] == cst ) F=F+1;
    }
    return res;
}

//stepJumps(cE,cT, 12)


// floors where optimal trials decrease (max N), for fixed numger of eggs
floorJumpsO1(eggs)={
    N=15;
    res=vDim(N);
    F=1;
    nr=approx(1,eggs)-1;
    while(nr<N){
        opt=approx(F,eggs);
        res[nr]= F;
        nr=nr+1;
        while ( approx(F,eggs) == opt ) F=F+1;
    }
    return res;
}

floorsApprox(eggs,N)={
    res=vDim(N);
    F=1;
    nr=approx(1,eggs)-1;
    while(nr<N){
        opt=approx(F,eggs);
        res[nr]= F;
        nr=nr+1;
        F= binarySearch((x)=> approx(x,eggs)>opt,F+1, 10*F );
    }
    return res;
}

floorsReal(eggs,N)={
    res=vDim(N);
    F=1;
    nr=0;
    while(nr<N){
    opt=mtb(F,eggs);
    res[nr]= F;
        nr=nr+1;
        F= binarySearch((x)=> mtb(x,eggs)>opt,F+1,2*F);
    }
    return res;
}

floorDiffJump(eggs,N)={
    un= vSort( floorsReal(eggs,N) U floorsApprox(eggs,N))[1..];
    res=vDim(vLen(un));
    lastDif= approx(1,eggs)- mtb(1,eggs) ;
    res[0]=vec(1,lastDif);
    p=1;
    for(i=1, i< vLen(un), i=i+1){
        dif= approx(un[i],eggs)- mtb(un[i],eggs) ;
        if (dif<lastDif){
            lastDif=dif;
            res[p]=vec(un[i],lastDif);
            p=p+1;
        }
    }
    return vTrunc(res,p);
}


ng=10
r=floorsReal(ng,15)  // at start optimal increases by 1 at log(floors,2) ...but it works only up to 2^(eggs+1) floors ?? afterward it change sooner
a=floorsApprox(ng,15)






d1=vDim(vLen(r)-1, (i)=> r[i+1]/r[i])
d2=vDim(vLen(d1)-1, (i)=> d1[i]/d1[i+1])





