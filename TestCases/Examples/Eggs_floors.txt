// max number of floors that can be measured with given number of eggs and measurement tries
mr(eggs, tries)={
    r=0;
    if (eggs>0) for(t=1, t<=tries, t=t+1) r=r+1+mr(eggs-1, t-1);
    return r;
}
// binomial coefficient alternative, faster than above recursive
// http://www.cs.umd.edu/~gasarch/BLOGPAPERS/eggold.pdf
mrb(eggs, tries)={
    r=0;
    for(i=1,(i<=eggs)&(i<=tries), i=i+1) r=r+ choose(tries,i);
    return r;
}


// min tries needed to test number of floors with given number of eggs in worst case
mt(floors, eggs)={
    if (floors==1) return floors;
    for(t=1,1,t=t+1) if (mrb(eggs,t)>=floors) return t;
}
// binary search optimized alternative to 'mt' :  mt(1e40,10)=3112ms,  mtb(1e40,10)=1ms ( both use mrb)
mtb(floors, eggs)={
    if ((eggs==1)|(floors==1)) return floors;
    twoEggSolution= ceiling((sqrt(8*floors+1)-1)/2);
    if (eggs==2) return twoEggSolution;
    startSearch= log(floors,2); // best case (smallest possible number of trials) with binary search
    endSearch= twoEggSolution; // worst case (most needed trials) is two eggs solution
    approx= (eggs!*floors)^(1/eggs); // optional further reduction of search ramge with approx result +- err
    if ( not isInfinity(approx)){
        err= eggs/2+2; // maximal approximation error (+2 just in case)
        startSearch= max(startSearch, approx-err);
        endSearch= min(endSearch, approx+err);
    }
    return binarySearch((t)=> mrb(eggs,t)>=floors ,  ceiling(startSearch), ceiling(endSearch));
}


// math formula for covered floors with N max trials, given fixed number of eggs
//      f1(N)= N                                        ; with 1 egg
//      f2(N)= sum(t=1..N) (1+f1(t-1)) = N*(N+1)/2       ; with 2 eggs
//      f3(N)= sum(t=1..N) (1+f2(t-1)) = N*(N^2+5)/6     ; with 3 eggs
//      f4(N)= sum(t=1..N) (1+f3(t-1)) = N*(N+1)*(N^2-3*N+14)/24     ; with 4 eggs
//      f5(N)= N*(N^4-5*N^3+25*N^2+5*N+94)
// or if f(N,E) is covered floors with N max trials and E eggs, then:
//      f(N,1)=N
//      f(N,E)= sum(t=1..N) (1+f(t-1,E-1))
// so mt(1000,3) can be solved by f3(N)>=1000 or N(N^2+5)/6>=1000 or N>=18.079 so N==19 
// wolfram can solve for N eggs:  
//      2 eggs(n=44.22): sum(a=0..n-1)(1+a)=1000
//      3 eggs(n=18.08): sum(b=0..n-1)(1+ sum(a=0..b-1)(1+a))=1000
//      4 eggs(n=12.72): sum(c=0..n-1)(1+ (sum(b=0..c-1)(1+ sum(a=0..b-1)(1+a))))=1000
//      5!eggs(n=10.95): sum(d=0..n-1)(1+(sum(c=0..d-1)(1+ (sum(b=0..c-1)(1+ sum(a=0..b-1)(1+a))))))=1000
// root solutions for different number of eggs, given F floors:
//      1: N=F
//      2: N=(sqrt(8*F+1)-1)/2
//      3: N~ (6*F)^(1/3) ≈ 0.48075*(1.73205*sqrt(243*F^2+125)+27*F)^(1/3)-3.46681/(1.73205*sqrt(243*F^2+125)+27*F)^(1/3) 
//      4:?N≈0.5*sqrt((0.333333*(205-288*F))/(18*sqrt(73728*F^3+50496*F^2+383792*F+62181)+8208*F+5363)^(1/3)+0.333333*(18*sqrt(73728*F^3+50496*F^2+383792*F+62181)+8208*F+5363)^(1/3)-6.33333)-0.5*sqrt(-(0.333333*(205-288*F))/(18*sqrt(73728*F^3+50496*F^2+383792*F+62181)+8208*F+5363)^(1/3)-0.333333*(18*sqrt(73728*F^3+50496*F^2+383792*F+62181)+8208*F+5363)^(1/3)-48/sqrt((0.333333*(205-288*F))/(18*sqrt(73728*F^3+50496*F^2+383792*F+62181)+8208*F+5363)^(1/3)+0.333333*(18*sqrt(73728*F^3+50496*F^2+383792*F+62181)+8208*F+5363)^(1/3)-6.33333)-12.6667)+0.5
//
// Single formula approximation for mt(floors, eggs):
//      minTrials= (eggs!*floors)^(1/eggs)  [+/-] eggs/2
//          errMin~ -[(eggs+1)*0.4]   , at floors==1 (approximation is larger than actual at low floors)
//          errZero= 0 , after floor = 2^[(eggs+3)/2] (approximation is close to actual after this floor )
//          errMax~ [eggs/2]-1  (approximation is smaller than actual at large number of floors)
//          initial errMin error is approx reduced by 1 on every *4 , for example on floors= 2*4^k
//      minTrialsCorr~ (eggs!*floors)^(1/eggs) - eggs/2+ log(floors/2,4) // not correct, just example !
// SINGLE FORMULA final solution ( limited , up to 5 devices for 600 & 1000 floors) :
//      min(d=1..5) (d*costDevice + [(d!*steps)^(1/d)+d/10]*costTrial)
//      Min[Map[ $3*#+$1*ceiling((#!*1000)^(1/#)+#/10)&, Range[5] ]]
mta(floors, eggs)={
    return ceiling((eggs!*floors)^(1/eggs) + eggs/10); // eggs/10 is partial correction for 500-1000 floors range
}





// at what floors to test with first egg, given total eggs and floors above/below test range
ft(aboveFloor, belowFloor, eggs)={
    floors= belowFloor-aboveFloor-1;
    t=mt(floors,eggs);
    f=0;
    r=vDim(t);
    for(i=0, f<floors, ){
        f=f+mr(eggs-1,t-i-1)+1;
        if (f<=floors){
            r[i]=f+aboveFloor;
            i=i+1;
        }
    }
    return vTrunc(r,i);
}



// optimal trials for different number of eggs, given fixed steps/floor count
// return vec( trials for 1 egg, trials for 2 eggs, ...) , stops at min possible value
// it has lower bound - when 'opt trials' <= 'number of eggs', opt trials can not go lower
// and that lower 'opt trial' bound can be reached much sooner than at same number of eggs
opT(floors)={
    res=vDim(1000);
    ot=1000;
    for(i=1, i<=ot+1, i=i+1){
        ot= mtb(floors,i);
        res[i-1]= ot;
    }
    while((ot>1)&(res[ot-1]==res[ot])) ot=ot-1;
    return vTrunc(res, ot+1); 
}

// costs with different number of eggs and their optimal trials 
cosT(floors, costEgg, costTrial)={
    o= opT(floors);
    return vDim( vLen(o), (i)=> (i+1)*costEgg+o[i]*costTrial);
}

// cheapest approach to measure floors, given costs of single measurement and egg
// return vec ( max cost, number of needed eggs, max tries)
bestC(floors, costEgg, costTry)={
    ctv= cosT(floors, costEgg, costTry);
    eggs= vMinIdx(ctv);
    return vec(ctv[eggs], eggs+1, mtb(floors,eggs+1));
}


cE=0; cT=1 ; nFloors=7
opT(nFloors)                // optimal trials for different number of eggs ( given fixed floors)
cs=cosT(nFloors,cE,cT)         // costs if different number of eggs is used
br=bestC(nFloors,cE,cT)     // lowest cost:  vec( maxCost, nDevices-eggs, maxTries) 



ft(0,nFloors+1,br[1],0)     // steps at which to test with first device (drop first egg)
ft(0,4,2)













