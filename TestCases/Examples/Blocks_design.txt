


BLOCKS ‼‼


 * - in case of x= expA ; expB; expC  - ; terminate, so it is same as mulitple lines of x= expA  then expB  then expC ...and result is again expC
 * - blocks { expA ; expB ; expC } - return value of last expression (expC here). Allow multiline blocks:
 *      f(x)={ 
 *                fi=(1+sqrt(5))/2;
 *                fi^x/sqrt(5)          // this is return value, since it is last one
 *           }
 * - blocks - allow definition of local variables within block, then hierarhichal name resolution
 *      f(x)={ // this is block B1
 *              x=5; // B1_x ==5, or ERROR? ( probably allow to overwrite param argument)
 *              z=x+3; // B1_z == B1_x+3 ==8
 *              { // this is block B1_1
 *                  x=7; // B1_1_x==7;
 *                  z;  // B1_z==8, use one from block B1. Z name resolution : look for name with its own block prefix (B1_1_z - not there), then parent block (B1_z - there!), then (z - not needed)
 *                  x+3; // == B1_1_x + 3 == 7+3 == 10 !  use inner block. X name resolution : look for its own block (B1_1_x - there), then parent block (B1_x - not needed here), then (x)
 *                  { // this is block B1_1_1
 *                      x=10; // B1_1_1_x==10;
 *                     x+3; // == B1_1_1_x + 3 == 10+3 == 10 !  use inner block. X name resolution : look for its own block (B1_1_x), then parent block (B1_x), then (x)
 *                  }
 *              }
 *              { // this is block B1_2
 *                  x=8; // B1_2_x = 8
 *                  x+3; // == B1_2_x + 3 == 8+3 == 11
 *              }
 *           } // end of block B1               
 *                  
 *                  



{
	fs= vec()
	while( vecLen(fs)<8 )
	{
		fs= fs U random(8)
	}
}



[0] - blockCounter at start
//inc last, so [1] (number/idx of this new block)
//and append [0] (means zero subblocks used so far in new block)
{B1 [1][0]  
	expR;
	{B1-1:  [1][1][0] - pass modified list, take care to copy it or pop later
		expA; 
		expC 
	} -> return expC value
	expZ;
	{B1-2:  [1][2][0]
		{ B1-2-1: [1][2][1]
			expA; 
		}
		return expB; 
		expC 
	} -> skip execution of expC and returns expB !
}

a) parse need List<int> blockCounter as parameter. 
	blockCounter.Length≡ which block depth we are
	blockCounter[2] ≡ number of blocks already existing at depth 2
	when entering next block, if current was [1]

b) mcFunc needs to have type block? ordered collection of mcFunc ?
   mcFunc as block.Evaluate() just call Eval() of each, until last, or until mcFunc marked as return

c) use ; as line separator within block  , but also implicit separator new line?
   that way entire document can still be treated as one topmost block

d) return from inner block in c# still exit entire function …what here ?
   need to have some topmost blocks (function start)? 
   below, return expB returns allway from f(x), while return expE returns just up to g(y)
   maybe functions to have implicit block that is of type funcBlock, and which "eats" return signal?
	f(x)= {
		   if(cond) {
				  expA;
				  return expB;
		    	     }
		   expMid;
		   g(y)=    {
			  	   expD;
				   return expE;
				   expDangling;
			     }
		   expF;
		   return expG;
		   expDangling;
		}


STACK ‼‼
// if functions can define or assign variables inside their bodies, then local variables within that function are not enough to have block depth !
// in case of recursions, same function may keep different versions of variables, so ... STACK !

f(x)={
	a=1/x
	return f(x+1)-a; // without stack, this inner call would rewrite value of this 'a' with its own 'a'
}

