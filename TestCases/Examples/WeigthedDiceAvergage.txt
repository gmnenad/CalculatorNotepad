// return RANDOM integer number 1..D, with distribution that has average value as fraction F or uniform one, and linear sloped PMF ( D dif.values )
dFlinear(i,D,F)= 1/3 // limited to 0.66 < F < 1.33 regardless of D, so  dF=1/3 
PMFlinear(i,D,F)={ // PMF(i) for line solution
    // pmf(i)= kA-kB*i , linear looking PFM is line highest at pmf(1) and sloped downward toward lowest pmf(D)
    kB= 6*(1-F)/D/(D-1);
    kA=1/D+kB/2*(D+1);
    return kA-kB*i;  // pmf
}
RNDlinear(D,F)={ // produce one random value directly, without using PMF
    // pmf(i)= kA-kB*i , linear looking PFM is line highest at pmf(1) and sloped downward toward lowest pmf(D)
    kB= 6*(1-F)/D/(D-1); // 12*((D+1)/2-avg)/D/(D^2-1);
    kA= 1/D+kB*(D+1)/2 ; // (1+3*(1-F)*(D+1)/(D-1))/D
    // we get uniform random in 0..1 range, representing c=cdf(i), and want to find 'i' corresponding to it
    c= rnd;  
    // cdf(i)= c = sum((k)=>pmf(k), 1,i) = i*(kA-kB*(i+1)/2) , and we can find i from c using quadratic eq
    a=kB/2;
    b=a-kA;
    i=(-b-sqrt(b^2-4*a*c))/2/a;
    // result is integer number 1..D, with required distribution that has average value 'avg' and linear looking PMF
    return max(1,ceiling(i));
}

 
// return RANDOM integer number 1..D, with distribution that has average value as fraction F or uniform one, and PMF with three steps ( 3 dif.values, 4 horiz.lines )
// ensure that L low numbers and H high numbers remain same as uniform p=1/D. GENERALIZE "step" (L=H= 0), "two step" (L=2,H= 0) and "three step" (L=H= W)
dFstepLH(D,L,H)=1-(2*(1+L)*(D-L-H)/(D+1)+L+H)/D  // limit for F:  1-dF < F < 1+dF. Real pmf/rnd should throw exception if F is over limit
PMFstepLH(i,D,F,L,H)={ // PMF(i) for three step solution with variable low and high unchanged width 
    if ((i<=L)|(i>D-H)) return 1/D; // for lowest and highmost numbers 'i', keep p(1..L)=p(D-H+1..D)=1/D , same as for uniform
    avg=(D+1)/2*(F*D-(L+H))/(D-L-H)-L;// average without L+H at edges, if L+1..D-H is replaced with d(D-L-H) ,  reduced by (D-L-H)/D since not always
    A=floor(avg); // last value in lower group
    pug=(2*avg-A-1)/(D-L-H); // prob to use upper group
    if (i<=A+L) p= (1-pug)/A; else p= pug/(D-L-H-A); // probability to use this number 'i', depending if its in lower or upper group
    return p*(D-L-H)/D; // modify probability since total prob is not 1, but rather (D-L-H)/D
}
RNDstepLH(D,F,L,H)={ // produce direct random value
    rG=rnd;
    if (rG<L/D) return floor(rnd*L+1); // if 1..L
    if (rG<(L+H)/D) return D-floor(rnd*H); // if D-H+1 ..D 
    avg=(D+1)/2*(F*D-(L+H))/(D-L-H)-L;// average without L+H at edges, if L+1..D-H is replaced with d(D-L-H) 
    A=floor(avg); // last value in lower group, offset by -W
    pug=(2*avg-A-1)/D; // prob to use upper group, corrected by D/(D-L-H) since sum(p)<1
    i= if (1-rG< pug, rnd*(D-A-L-H)+A, rnd*A); // random number from one (also random) group 
    return floor(i+1+L);  
}

// test average
tst(D,F,N)={
   s=0;
   valMin=+100000; valMax=-100000;
   for(i=0, i<N, i=i+1){
   r= RNDstepLH(D,F,1,1);
        s=s+r;
        if (r<valMin) valMin=r;
        if (r>valMax) valMax=r;
        
   }
   return vec(s/N, (D+1)/2*F, valMin, valMax);
}


f=0.75
D=12
tst(D,f,100000)   
    
v=vDim(D,(i)=>PMFstepLH(i+1,D,f,1,1))
vec( v[0],v[1],v[D-2],v[D-1])
vSum(v) // should ==1
vMin(v) // should >0
vSum(vFor((i)=>(i+1)*v[i],vLen(v)))*2/(D+1) // should== F

dFstepLH(12,2,1)






 
 
 
 
 
 
 