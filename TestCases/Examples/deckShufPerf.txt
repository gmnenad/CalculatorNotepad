mix(v)={
    n=vLen(v);
    nh=floor(n/2);
    res=vDim(n);
    for(i=0, i<nh, i=i+1){
        res[2*i]=v[i+nh]; // i+nh
        res[2*i+1]=v[i];
    }
    return res;
}

mixAll(n)={
    v0=vDim(n,(i)=>i+1);
    v=mix(v0);
    i=1;
    while(v!=v0){
    v=mix(v);
        i=i+1;
    }
    return i;
}

vDim(26,(i)=>mixAll(2*i+2))

d=52



na(D)= {n=1; for(p=1,p!=0,n=n+1) { p=2*p+1; if(p>=D) p=p-D-1; }; return n;}
nb(D)= {n=1; for(p=2,p!=1,n=n+1) { p=2*p;   if(p>=D) p=p-D+1; }; return n;}

mixAll(d)
na(d)

fd=52
makeMap(52)
cntD(fd)
testD(44)

findLongest(D,n)={
    c=0; mpc=0;
    for(i=1, i<=n, i=i+1){
        mp= rndShuffle(D);
        nc= cntD(D,mp);
        if (nc>c){
            c=nc;
            mpc=mp;
        }
    }
    return vec(c,mpc);
}

// Landau's function: https://oeis.org/A000793
maxSeq(10,1) 
//v(180180,v(41,28,38,0,27,22,49,39,16,10,6,1,50,43,35,44,31,4,48,36,19,9,14,18,30,51,34,26,29,46,8,23,13,40,7,17,42,5,25,47,20,3,11,2,12,24,33,37,45,21,15,32))
//v(180180,v(51,28,44,13,16,2,12,21,47,5,36,9,46,14,42,15,3,6,39,37,0,31,8,4,25,10,22,49,18,30,23,32,7,48,43,45,38,50,27,40,41,19,29,20,35,26,1,11,33,24,17,34))
//v(180180,v(8,23,3,42,43,18,7,0,4,49,50,15,25,6,10,16,19,35,30,14,27,46,32,13,33,36,48,40,38,24,31,45,39,41,17,37,28,34,9,22,29,26,51,2,20,5,12,44,47,21,11,1))
//#C#
// Qualman1- perfect interleave,  1st card become 2nd
void shuffle1(int D, ref int[] deck){
    var dd= deck.ToList();
    int d2= D/2;
    for(int i=0;  i<d2 ; i++){
        deck[2*i]=dd[i+d2];
        deck[2*i+1]=dd[i];
    }    
}

// fibonacci shuffle
void shuffle2(int D, ref int[] deck){
    var dd= deck.ToList();
    int a=1,b=1,p=0;
    while(p<D){
        int nb=a+b; a=b; b=nb; // next fibonacci 
        int idx=b % dd.Count;  // select next card
        deck[p++]=dd[idx];
        dd.RemoveAt(idx);
    }    
}

// create map
int[] makeMap(int D){
    var map=new int[D];
    for(int i=0; i<D; i++) map[i]=i;
    shuffle1(D,ref map);
    return map;
}

// how many times need to shuffle to return back to original?
int cntD(int D, int[] map=null){
    if (map==null) map=makeMap(D);
    int[] deck0= new int[D], deck1= new int[D], deckT;
    for(int i=0; i<D; i++) deck0[i]=i;
    int cnt=0;
    bool ok;
    do{
        cnt++;
        // shuffle using map
        for(int i=0; i<D; i++) deck1[i]=deck0[map[i]];
        // swap decks
        deckT=deck0; deck0=deck1; deck1=deckT;
        // test if finished
        ok=true;
        for(int i=0; ok&&(i<D); i++) if (deck0[i]!=i) ok=false;
    } while (!ok);
    return cnt;
}

// test up to D, largest cnt(D) where cnt(D)>D ?
int[] testD(int D){
    int bc=0, bd=0;
    for(int d=2; d<=D; d+=2){
        int c=cntD(d);
        if((c>d)&&(c>bc)){ bc=c; bd=d; }
    }
    return new int[2]{ bd, bc };
}

// find longest sequence for given deck size D . Search up to N times
// result= vec( maxSeqLength, % of trials with that max length )
double[] maxSeq(int D, int n){
    int c=0, cOld=0;
    for(int i=1; i<=n; i++){
        var mp= nm.rndShuffle(D);
        int nc= cntD(D,mp);
        if (nc>c){
            c=nc;
            cOld=1;
        }else
            if (nc==c) cOld++;
    }
    return new double[2]{c, 100.0*cOld/(double)n};
}
    